TODO:

	About:

		Linq style collection search tool
		collections must be array of: objects or dictionaries
		queries can be created statically or at runtime

# =================================================================
    Code taste:

        how similar to linq should it be?
            what ways can gdscript be uniquely leveraged/advantaged
			should revolve more around database/mongo style than linq
		generally move towards objects as opposed to raw dictionaries
			wrap dictionary in default class
			think mongo db c# (BSON)

		library modules
		
		db class vs IterList of Lists
			add collection vs IterList.first({name=collection_name})

		move to object based construction
			IterList an extension (not pure lib)
				should use builder internally

		chainer there to make things easy - detect types etc

		iterators should limit possible functions
			i.e. no Count().Select()
			SelectIterator, EndQueryIterator
# =================================================================
    improvements/planned features:	
		
		remove chainer
		remove old example to history folder or .ignore
		hide shopkeeper example, iterlist also

		make sure it is obvious which functions need to take array as argument
		readme/docs

		rename Enumerators?

				
		### github ###
	
		simple documentation with examples for each 
			like linq docs

        select, where with func
            i.e. lambda
				able to read key and value
				var age_comp = GLF.and_([GLF.gt(20), GLF.lt(100)])
				var cash_comp = GLF.gt(1200)
				var chain = Builders.ChainerKV.start()\
					.where(and([{age=age_comp}, {cash=cash_comp}]))
					.where(or([{age=age_comp}, {cash=cash_comp}]))

					.where(AllValues.new({age=age_comp, cash=cash_comp}))
					.where(AnyValues.new({age=age_comp, cash=cash_comp}))
					.where(CompValue.new({age=age_comp})) == .where({age=age_comp}) # detect dictionary

					.where(PredKeyValueFunc.new(["name", "score"], score_is_invalid))
					.where(PredItemFunc.new(score_is_invalid))

					.select(GetValue.new(["field0", "field1"]))
					.select(SelectorGetKeys.new()) | .select(SelectorGetValues.new())
					.select(KeyValueFunc.new(["name", "score"], mult_by_2_func))
					.select(SelectorDict.new({score=mult_by_2_selector})) # return [{score:N*2}]
					.select({name=name_func, score=score_func}) # will be cast to SelectorDict
					.select(SelectorItemFunc.new(score_func))

		var query = [Where(pred), First()]
		for itm in data.apply(query): do_thing(i)
			returns new IterList
		
		built in support for unique-id system

		functions
			change:
				append, remove -> return copy of original
				combine/union?
			generation (a la numpy):
				repeat(i) -> list of i repeated N times
			mathematical:
				sum, average, min, max

		search/select keys and values??

		json
			+ write support - not sure this is necessary

		better examples showing all major features

		monitoring/signals
			observer pattern
			on_destroy/create

		some method for accessing nested fields
			In builder method?:
				Start().First(cmps).Open("inventory").First({type=eq("sword")})


		actions (on data):
		for_each(action)
		mathematical functions
			Add, Sub, Mult, Div, Mod
		Append/Erase on signal/event?

		schema - some way to ensure inserted items fit template

	test library - gut??

	ecs impl example
		requires id system
		
Shopkeeper example
	use builder method to avoid duplicate comparisons

	how to handle multiplication of values by price
		for_each??
		pass edited list to gui for display

	show item stats
		in hover/tooltip
		or use center panel

	refactor gui code
		set nodes in gui scene, get using variable
		set player name from exported var
		
	UI:
		;::;
		®∫®¬g
		o/
		
	dialogue: (? separate example ?)
		search wares, gossip