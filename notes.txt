TODO:

	About:

		Linq style collection search tool
		collections must be array of: objects or dictionaries
		queries can be created statically or at runtime

# =================================================================
    Code taste:

		project returns selection of kv pairs, select allows functions and returns copy?
			.project(["addr_id", "street", "value"], PROJECTION_INCLUDE)
			.select({value=mult(2)})

		should revolve more around database/mongo style than linq
			database -> collection -> document

			filt = QueryBuilder.Filter.new({health=Ops.Compare.gte(0)})
			upd_fx = QueryBuilder.UpdateMath.new({health=Ops.Update.sub(1)})
			upd_rm = QueryBuilder.UpdateRemove.new({health=Ops.Compare.lt(0)})
			upd = QueryBuilder.Update.Chain.new([upd_fx, upd_rm])
			data.update(filt, upd)

						===== OR =====

			upd = QueryBuilder.new()
				.where({health=Ops.Compare.gte(0)})
				.update({health=Ops.Update.sub(1)})
				.rm_where({health=Ops.Compare.lt(0)})
			result = upd.apply(data).to_list()

		should first take arguments?
			not really; .where({}).first_or_default()

		generally move towards objects as opposed to raw dictionaries?
			wrap dictionary in default class internally?
			think mongo db c# (BSON)
		
		db class vs IterList of Lists
			add collection vs IterList.first({name=collection_name})

		move to object based construction
			IterList an extension (not pure lib)
				should use builder internally

		iterators should limit possible functions
			i.e. no Count().Select()
			SelectIterator, EndQueryIterator
			Where -> Update == valid
			Select -> Update == NOT valid

# =================================================================
    improvements/planned features:	

		RF enumerators_new 

		first, last, at, count
		????	first(comps), front() || last(comps), back()	????
			OR first(comps=[])
		
		
		iterators should limit possible functions
			i.e. no Count().Select()
			SelectIterator, EndQueryIterator

		first callable with/without args?

		query types (only on iterlist/editable):
			update_one, update_many, update_n
			add
			remove

		readme/docs

		rename Enumerators?
			look up definition + look at other libs use of language
				
		remove messy/depreciated examples

		tests - at least run every function once

		built in support for unique-id system
			is there a solution/function built in?

		### github ###

		convert original example to gui + search options

		simple documentation with examples for each 
			like linq docs

        select, where with func
            i.e. lambda
				able to read key and value
				var age_comp = GLF.and_([GLF.gt(20), GLF.lt(100)])
				var cash_comp = GLF.gt(1200)
				var chain = Builders.ChainerKV.start()\
					.where(and([{age=age_comp}, {cash=cash_comp}]))
					.where(or([{age=age_comp}, {cash=cash_comp}]))

					.where(AllValues.new({age=age_comp, cash=cash_comp}))
					.where(AnyValues.new({age=age_comp, cash=cash_comp}))
					.where(CompValue.new({age=age_comp})) == .where({age=age_comp}) # detect dictionary

					.where(PredKeyValueFunc.new(["name", "score"], score_is_invalid))
					.where(PredItemFunc.new(score_is_invalid))

					.select(GetValue.new(["field0", "field1"]))
					.select(SelectorGetKeys.new()) | .select(SelectorGetValues.new())
					.select(KeyValueFunc.new(["name", "score"], mult_by_2_func))
					.select(SelectorDict.new({score=mult_by_2_selector})) # return [{score:N*2}]
					.select({name=name_func, score=score_func}) # will be cast to SelectorDict
					.select(SelectorItemFunc.new(score_func))

		var query = [Where(pred), First()]
		for itm in data.apply(query): do_thing(i)
			returns new IterList
		
		functions
			change:
				append, remove -> return copy of original
				combine/union?
			generation (a la numpy):
				repeat(i) -> list of i repeated N times
			mathematical:
				sum, average, min, max

		search/select keys and values??

		json
			+ write support - not sure this is necessary

		better examples showing all major features

		monitoring/signals
			observer pattern
			on_destroy/create

		some method for accessing nested fields
			In builder method?:
				Start().First(cmps).Open("inventory").First({type=eq("sword")})


		actions (on data):
		for_each(action)
		mathematical functions
			Add, Sub, Mult, Div, Mod
		Append/Erase on signal/event?

		schema - some way to ensure inserted items fit template

	test library - gut??

	ecs impl example
		requires id system
		
Shopkeeper example
	use builder method to avoid duplicate comparisons

	how to handle multiplication of values by price
		for_each??
		pass edited list to gui for display

	show item stats
		in hover/tooltip
		or use center panel

	refactor gui code
		set nodes in gui scene, get using variable
		set player name from exported var
		
	UI:
		;::;
		®∫®¬g
		o/
		
	dialogue: (? separate example ?)
		search wares, gossip

NEW:
	first(comps), front() || last(comps), back()
	list.where(comps)
		returns EnumeratorWhere
	list.where(comps).front()
		returns Object # having run where enumerator once + FrontEnumerator
